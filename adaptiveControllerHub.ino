// This file is the control code for the adaptive controller system hub

// TODO - consider adding a "unique ID" using the mac address, device type, and possibly something else to prevent MAC spoofing - probably overkill but why not right?

#define PRESSED LOW

#define ESPNOW_WIFI_IFACE WIFI_IF_STA
#define ESPNOW_PAIRING_PMK = "pmk1234567890123"
#define ESPNOW_PAIRING_LMK = "lmk1234567890123"
#define DEV_TYPE_HUB = 0x01


#include <WiFi.h>
#include <esp_mac.h>
#include <vector>
#include <string>
#include "mbedtls/sha256.h"


struct digitalButton {
  short pinNum;
  bool lastState = HIGH;
  unsigned long stateChangeTime = 0;
  String name;
  char btnIndx = 0;
};

struct analogButton {
  short pinNum;
  int lastState = 0;
  unsigned long stateChangeTime = 0;
  String name;
  char btnIndx = '0';
};

digitalButton BUTTON_UP; 
digitalButton BUTTON_RT; 
digitalButton BUTTON_DN; 
digitalButton BUTTON_LT; 
digitalButton BUTTON_BM; 
digitalButton BUTTON_J5; 
digitalButton D_PAD_UP;
digitalButton D_PAD_DN;
digitalButton D_PAD_LT;
digitalButton D_PAD_RT;
// digitalButton BUTTON_K; 

analogButton ANLG_JOY_X_AXIS; 
analogButton ANLG_JOY_Y_AXIS;
analogButton ANLG_TRG;


/* ========== Begin ESPNOW Network Data Code ==========*/


#define WIFI_CHANNEL 11

enum MsgType : uint8_t {
  MSG_PAIRING = 0x01,
  MSG_PAYLOAD = 0x02
};
enum DevType : uint8_t {
  DEV_HUB = 0x01,
  DEV_PERIPHERAL = 0x02
};

// ESPNOW struct configs
#pragma pack(push, 1)
struct pairingData {
  MsgType type;
  DevType devType;
  uint8_t numBtns;
  uint8_t numAnlgs;
  char lmk[16];
  char secret[16];
  uint8_t channel;
}
#pragma pack(pop)

#pragma pack(push, 1)
struct payload {
  MsgType type;
  uint16_t btnStates;
  uint32_t anlgStates[4];
}
#pragma pack(pop)

String macAddress;
const DevType devType = 0;
const uint8_t numBtns = 11;
const uint8_t numAnlgs = 2;
const string lmk = "lmk9876543210987";
uint8_t channel = 0;
bool pairingMode = false;

// Helper Functions

// secret is generated by the hub at generation and shared during pairing mode. Salt is hub mac address
void derivePMK(const std::string& secret, const std::string& salt, uint8_t output[16])
{
  std::string combinedSalt = secret + salt;
  uint8_t fullHash[32];
  mbedtls_sha256((const uint8_t*)combinedSalt.c_str(), combinedSalt.length(), fullHash, 0);
  memcpy(output, fullHash, 16);
}

void registerNewPeer(const esp_now_recv_info_t *info, const uint8_t *data, uint8_t len, void *arg)
{

}

std::vector<payload> recvdMsgs;
std::vector<ESP_NOW_NETWORK_PERIPHERAL> peripherals;

class ESP_NOW_NETWORK_PERIPHERAL : public ESP_NOW_PEER {
  public:
    uint16_t devType;
    uint8_t numBtns;
    uint8_t numAnlgs;
    // string lmk;

    ESP_NOW_NETWORK_PERIPHERAL(const uint8_t *mac_addr, uint16_t devType, uint8_t numBtns, uint8_t numAnlgs, const uint8_t *lmk = (const uint_t *)ESPNOW_PAIRING_LMK)
      : ESP_NOW_PEER(mac_addr, ESPNOW_WIFI_CHANNEL, ESPNOW_WIFI_IFACE, lmk), devType(devType), numBtns(numBtns), numAnlgs(numAnlgs) {}
    
    ~ESP_NOW_NETWORK_PERIPHERAL() {}

    // bool begin()
    // {
    //   if(!add())
    //   {
    //     log_e("Failed to initialize ESP-NOW or register the peer");
    //   }
    // }

    bool send_message(const uint8_t *data)
    {
      if (data == NULL || sizeof(*data) == 0)
      {
        log_e("Payload is NULL or has length 0");
        return false;
      }
      return send(data, sizeof(*data));
    }

    void onRecieve(const uint8_t *mac_addr, const uint8_t *data, size_t len)
    {
      // Make sure packets came in properly - if size is damaged then abort
      if (len < sizeof(MsgHeader))
      {
        log_e("Payload not received properly - size too small for message header");
        return
      }

      // grab the header
      MsgType type = static_cast<MsgType>(data[0]);

      switch(type)
      {
        case MSG_PAIRING:
          if(len != sizeof(pairingData))
          {
            log_e("Pairing data missing - aborting packet");
            return;
          }
          /* ==== Register pairing data ==== */
          // if this is the hub
          if(devType == DEV_TYPE_HUB)
          {
            esp_now_peer_info_t newPeer = {};
            memcpy(newPeer.peer_addr, mac_addr*, 6);
            peer.channel = channel;
            peer.encrypt = true;
            memcpy(peer.lmk, deriveLMK(mac_addr), 16);
            esp_now_add_peer(&peer);
          }
          // if this is a peripheral
          else
          {

          }

          break;
        case MSG_PAYLOAD:
          if(len != sizeof(payload))
          {
            log_e("Payload data missing - aborting packet");
            return;
          }
          /* ==== Update controller state ==== */
          // create temp holder for payload
          payload *tempData = (payload *)malloc(sizeof(payload));
          // verify memory allocation
          if(!tempData)
          {
            log_e("Dropped payload - failed memory allocation");
          }
          // copy payload to allocated memory
          memcpy(tempData, data, sizeof(payload))
          // add payload to queue
          recvdMsg.push_back(tempData)


          break
        default:
          log_e("Unknown packet type received - aborting packet");
          break;
      }
      
    }
}

/* ========== End ESPNOW Network Data Code ==========*/















void setup() {
  // put your setup code here, to run once:

}

void loop() {
  // put your main code here, to run repeatedly:

}
